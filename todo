===========================================================
HCiteService

CRUD for Reference (Name)
keyed uniquely by referenceSerial(Int), for graph, we need it as Address

C- by Import
      Bibtex import

R- by Search

U- by insert and decommission

D- never deletes, just decommission

CRUD for Person (Owner :: Address)
keyed uniquely by Address (and as a Signer),
it means we have another set of data, that is Person.
to hold the Person details of Owner :: Address.
And we have map between 1 Address -> 1 Person

In conclusion, we have:
1 Address -> 1 Person
1 Address -> 1 Reference
so we can build a graph of
Graph Address       Address
      Reference     Person

because internally, the graph have same constituents (Address),
it means, we can make relation 1 person to many reference, or
1 reference to many person.
And we can load this relation as a graph.
for the moment, we have 2 schemes:
  internally, we save it as a Store.Map AddressRef [AddressPerson].
  Then, on every update (or init), we load it as a Graph.
  Question remains:
  How to initiate all Connect when HCiteService starts?
  How to update Connect every after update Map?
  Probably, we need to update sdk to implement it in every time Consensus reached.

Conclusion for the moment:
- implement Store.Map AddressRef [AddressPerson]


C-

R-

U- by insert

D-

one owner can have many names.
one person can have many reference.
actually, vice versa, and we need query in both direction.


CRUD for Interconnect Person and Reference,
this is the real whois.
It connects PersonIds and ReferenceId.
The map is:
single referenceId to Many PersonId.
or
single personId to Many ReferenceId
we can use these alternatives:
- Tendermint.SDK.BaseApp.Store.Map as Map
- ALGA: https://nobrakal.github.io/alga-tutorial/#an-example-a-social-network
- Data.Relation: https://github.com/haskell-works/relation/blob/master/test/Data/RelationSpec.hs

basically we can use Store.Map right away, but maybe we can improve to ALGA.
Data.Relation provide input as a Map, maybe different with Haskell's Map.
Thus, it will different and complexity would be equal with ALGA.
Thus, we can right away go to ALGA.

1. Implementation on map:


C- buy

R

U

D


- implement gas
- implement reference
- generate signer
- load signer from file key
  - with password



==========================================================
FOR MYSQL BACKEND
CRUD of Reference
C- by Import
v     Bibtex import

R - by Search
v     implement pagedHome
v     implement Abstract dynamic
v     implement Search
v       at upper part of Home
v       as json_data with space as &&.
v       by author, keyword,
v       abstract,
v       by ownerId
v       need to combine ownerId with other modes of search, means SearchModel including int
v       need to add search to last page as 0
U - by Details
v     implement EditRecords

D - Unimplemented (never delete data)

CRUD of Person
C - by DB

R - by pickOwner
v     implement pickOwner with Search, as updated Dropdown list
v     implement DetailedView with editing onClick at the field

U - by DB

D - by DB

Interconnect Person and Reference
C - assignOwner
v implement setOwner

R - in DetailedView
  implement viewWithOwner in Details

U - in DetailedView
v implement deAssignOwner

D - in DetailedView
v implement deAssignOwner

View based
  Better view
  implement Acknowledgements
v implement Settings as Env
v implement Authorization by SessionStorage, not LocalStorage for security
v implement "Not yet Implemented"
v implement links: but we need to remove it, because android and gtk cannot handle it well
v implement Login, tinggal pakai token untuk post data
